<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>非对齐地址访问的总结和疑问</title>
    <link href="/2022/01/30/2022-1-30%E9%9D%9E%E5%AF%B9%E9%BD%90%E5%9C%B0%E5%9D%80%E8%AE%BF%E9%97%AE/"/>
    <url>/2022/01/30/2022-1-30%E9%9D%9E%E5%AF%B9%E9%BD%90%E5%9C%B0%E5%9D%80%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是非对齐访问"><a href="#什么是非对齐访问" class="headerlink" title="什么是非对齐访问"></a>什么是非对齐访问</h2><p>在机器指令层面，当尝试从不能被 N 整除 (addr % N != 0) 的<strong>起始地址</strong>读取 N 字节的数据时即发生了非对齐内存访问。举例而言，从地址 0x10004 读取 4 字节是可以的，然而从地址 0x10005 读取 4 字节数据将会是一个非对齐内存访问。这里 N 就是数据的自然对齐值 (Natural alignment)。</p><p><strong>RISC</strong>下使用访存指令读取或写入数据单元时，目标地址必须是所访问之数据单元字节数的整数倍，例如MIPS架构是不支持非对齐访问的。</p><p><strong>CISC</strong>访存时，如果目标地址不对齐，CPU 不会陷入异常，因为其内部有处理非对齐访问的微程序，例如X86是支持非对齐访问的。</p><p>ARMV6首次在硬件层面引入了非对齐访问的支持。更早期的ARM处理器需要在软件层面考虑非对齐访问。</p><p>编译器在绝大部分时候都能帮我们搞定这个棘手的事情，满足对齐需求。通常编译器会处理好数据对齐的问题，变量分配时的地址都会是自然对齐的。</p><p>一些情况下非对齐访问并不会抛出错误，但是会损失性能。</p><h2 id="ARM-cortex下非对齐访问的问题和结论"><a href="#ARM-cortex下非对齐访问的问题和结论" class="headerlink" title="ARM cortex下非对齐访问的问题和结论"></a>ARM cortex下非对齐访问的问题和结论</h2><p>在ARM cortexM0内核的单片机中，在使用指针进行内存访问的时候需要特别留意访问地址的合法性问题，否则会进入HardFault。</p><p>结论：</p><p>1、u8类型的指针，读写任何地址均是合法的，不会进入HardFault</p><p>2、u16类型的指针，读写地址必须是2的倍数，否则会进入HardFault</p><p>3、u32类型的指针，读写地址必须是4的倍数，否则会进入HardFault</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="u8访问内存"><a href="#u8访问内存" class="headerlink" title="u8访问内存"></a>u8访问内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> pack(4)<span class="hljs-comment">//预编译指定对齐是4字节</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>u8 len;<span class="hljs-comment">//自身对齐是1，指定对齐是4，因此有效对齐是1, 0地址存放len</span><br>u8 data[<span class="hljs-number">12</span>];<span class="hljs-comment">//自身对齐是1，指定对齐是4，因此有效对齐是1, 1地址存放data[0],2地址存放data[1]...</span><br>&#125; TEST;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> pack()</span><br><br>TEST test;<br><br>u8  *p8;<br>u16 *p16;<br>u32 *p32;<br><span class="hljs-keyword">volatile</span> u32 temp;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">align_test_p8</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>p8  = (u8  *)&amp;test.data[<span class="hljs-number">0</span>];<span class="hljs-comment">//test.data[0]的地址为奇数</span><br><br>temp = p8[<span class="hljs-number">0</span>];<span class="hljs-comment">//访问非对齐地址</span><br>temp = p8[<span class="hljs-number">1</span>];<span class="hljs-comment">//访问2字节对齐的地址</span><br>temp = p8[<span class="hljs-number">2</span>];<span class="hljs-comment">//访问非对齐地址</span><br>temp = p8[<span class="hljs-number">3</span>];<span class="hljs-comment">//访问4字节对齐地址</span><br>&#125;<br></code></pre></td></tr></table></figure><p>程序不会进入HardFault</p><h3 id="u16访问内存"><a href="#u16访问内存" class="headerlink" title="u16访问内存"></a>u16访问内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">p16  = (u16 *)&amp;test.data[<span class="hljs-number">0</span>];<br>temp = p16[<span class="hljs-number">0</span>];<span class="hljs-comment">//访问非2字节对齐的地址，肯定会进入HardFault</span><br><br>p16  = (u16 *)&amp;test.data[<span class="hljs-number">1</span>];<br>temp = p16[<span class="hljs-number">0</span>];<span class="hljs-comment">//访问2字节对齐地址，不会进入HardFault</span><br><br>p16  = (u16 *)&amp;test.data[<span class="hljs-number">2</span>];<br>temp = p16[<span class="hljs-number">0</span>];<span class="hljs-comment">//访问非2字节对齐地址，会进入HardFault</span><br><br>p16  = (u16 *)&amp;test.data[<span class="hljs-number">3</span>];<br>temp = p16[<span class="hljs-number">0</span>];<span class="hljs-comment">//访问2字节对齐地址，不会进入HardFault</span><br></code></pre></td></tr></table></figure><h3 id="u32访问内存"><a href="#u32访问内存" class="headerlink" title="u32访问内存"></a>u32访问内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C">p32  = (u32 *)&amp;test.data[<span class="hljs-number">0</span>];<br>temp = p32[<span class="hljs-number">0</span>];<span class="hljs-comment">//访问非4字节对齐的地址，进入HardFault</span><br><br>p32  = (u32 *)&amp;test.data[<span class="hljs-number">1</span>];<br>temp = p32[<span class="hljs-number">0</span>];<span class="hljs-comment">//访问2字节对齐地址，但不是4字节对齐地址，会进入HardFault</span><br><br>p32  = (u32 *)&amp;test.data[<span class="hljs-number">2</span>];<br>temp = p32[<span class="hljs-number">0</span>];<span class="hljs-comment">//访问非4字节对齐地址，进入HardFault</span><br><br>p32  = (u32 *)&amp;test.data[<span class="hljs-number">3</span>];  <span class="hljs-comment">//根据结构体字节对齐的规则，test.data[3]的地址肯定是2的倍数，是4的倍数</span><br>temp = p32[<span class="hljs-number">0</span>];  <span class="hljs-comment">//访问4字节对齐地址，不进入HardFault</span><br></code></pre></td></tr></table></figure><h2 id="RISC-V-MCU非对齐访问的问题的发现"><a href="#RISC-V-MCU非对齐访问的问题的发现" class="headerlink" title="RISC-V MCU非对齐访问的问题的发现"></a>RISC-V MCU非对齐访问的问题的发现</h2><p>我在RISC-V内核的CH32V307上调试base64编码的程序的时候，总是会在编码的时候进入HardFault循环，经过排查，没有内存溢出和其他的可能性，而且都是在第二次循环进入HardFault，于是考虑到了是不是地址的问题，经过查询，确定了应该是非对齐访问的问题。</p><p>我使用的Base64编码程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">uint32_t</span> b0: <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">uint32_t</span> b1: <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">uint32_t</span> b2: <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">uint32_t</span> b3: <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">uint32_t</span> nop: <span class="hljs-number">8</span>;<br>&#125; byte3;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">to_base64</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>* src, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">uint8_t</span> *buf)</span></span>&#123;<br>    <span class="hljs-keyword">uint8_t</span>* buf_init = buf;<br>    <span class="hljs-keyword">while</span>(len &gt;= <span class="hljs-number">3</span>)&#123;<br>        *(buf++) = raw_to_base64[((byte3*)(src))-&gt;b0];<br>        *(buf++) = raw_to_base64[((byte3*)(src))-&gt;b1];<br>        *(buf++) = raw_to_base64[((byte3*)(src))-&gt;b2];<br>        *(buf++) = raw_to_base64[((byte3*)(src))-&gt;b3];<br>        src += <span class="hljs-number">3</span>;<br>        len -= <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">switch</span>(len)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        *(buf++) = raw_to_base64[((byte3*)(src))-&gt;b0];<br>        *(buf++) = raw_to_base64[((byte3*)(src))-&gt;b1];<br>        *(buf++) = raw_to_base64[((byte3*)(src))-&gt;b2 &amp; <span class="hljs-number">0x0f</span>];<br>        src += <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        *(buf++) = raw_to_base64[((byte3*)(src))-&gt;b0];<br>        *(buf++) = raw_to_base64[((byte3*)(src))-&gt;b1 &amp; <span class="hljs-number">0x03</span>];<br>        src += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> buf - buf_init;<br>&#125;<br></code></pre></td></tr></table></figure><p>先看byte3这个结构体，结构体内有5个成员，虽然都是uint32_t类型的，但是后面都有：显示位域，所以前四个成员均占用6个位，最后一个成员占用8个位。也就是这个结构体占用32位（4个字节）。</p><p>然后再看    raw_to_base64[((byte3 * )(src))-&gt;b0];    这句话，src本来是u8类型的指针，(byte3 * )(src)将src变成了32位的指针，这为非对齐访问买下了伏笔。</p><p>经过Debug，我发现每次程序都会卡在while的第二次循环的 * (buf++) = raw_to_base64[((byte3 * )(src))-&gt;b0];这句话。经过Debug：</p><p>初始化进入这个函数时，src的地址是0x20005c88，当第二次执行上述语句使，src的地址为0x20005c8b。</p><p>我们可以发现0x20005c88 % 4 = 0，0x20005c8b % 4 = 3。显然是发生了非对齐访问造成的硬件中断。</p><p>RISC-V手册</p><p><a href="http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf">http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf</a></p><p>中对于非对齐访问的描述：</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202201301530482.png"></p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202201301528499.png"></p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202201301526961.png"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>RISC-V</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CH573ADC不同于传统32的使用配置</title>
    <link href="/2022/01/30/2022-2-11CH573ADC%E4%B8%8D%E5%90%8C%E4%BA%8E%E4%BC%A0%E7%BB%9F32%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/01/30/2022-2-11CH573ADC%E4%B8%8D%E5%90%8C%E4%BA%8E%E4%BC%A0%E7%BB%9F32%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="CH573的ADC"><a href="#CH573的ADC" class="headerlink" title="CH573的ADC"></a>CH573的ADC</h1><p>CH573是基于RISC-V的搭载BLE的MCU。搭载12位ADC，支持差分输入和单端输入，拥有10路外部输入通道和2路内部信号，支持DMA。并且支持触摸按键检测模块。可以选择PGA进行增益调节。ADC 输入电压范围 0V～VIO33。</p><p>CH573ADC模块的框图：</p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202202111504728.png" style="zoom:80%;" /><h2 id="关于增益（PGA）"><a href="#关于增益（PGA）" class="headerlink" title="关于增益（PGA）"></a>关于增益（PGA）</h2><p>CH57x,ch58x 系列的芯片内部的ADC的实现方式是逐次比较型的(SAADC),其半量程参考电压是<strong>1.05v</strong>.默认的电压测量范围是0-2.1v<br>芯片ADC的前级提供了一个PGA,可以通过调整其放大倍数,来实现不同的量程。</p><p>PGA 增益选择与输入电压范围表：</p><table><thead><tr><th>PGA增益</th><th align="center">采样值到电压换算</th><th>理论可测电压上限</th><th>理论可测电压范围(Vref=1.05V)</th><th>建议实际测量电压范围</th></tr></thead><tbody><tr><td>-12dB(1/4 倍)</td><td align="center">(ADC/512-3)*Vref</td><td>5*Vref</td><td>-0.2V ～ VIO33+0.2V</td><td>2.9V ～ VIO33</td></tr><tr><td>-6dB(1/2 倍)</td><td align="center">(ADC/1024-1)*Vref</td><td>3*Vref</td><td>-0.2V ～ 3.15V</td><td>1.9V ～ 3V</td></tr><tr><td>0db(1倍)</td><td align="center">(ADC/2048)*Vref</td><td>2*Vref</td><td>0V ～ 2.1V</td><td>0V ～ 2V</td></tr><tr><td>6db(2倍)</td><td align="center">(ADC/4096+0.5)*Vref</td><td>1.5*Vref</td><td>0.525V ～ 1.575V</td><td>0.6V ～ 1.5V</td></tr></tbody></table><p>Vref是内部模拟电路的电源节点 <strong>VINTA</strong> 的实际电压值，通常为 1.05V ± 0.015V。</p><p>根据手册要求，VINTA引脚需要接大于0.1uF的电容到地（启用DC-DC时1uF或2.2uF）。</p><p><strong>关于大幅测量范围的PGA选用：</strong>理论可测是设计可测的范围参数；实际建议使用是根据实测结果，对测试范围进行进一步细化，误差最小的建议测量范围。如果进行0-3.3V全幅的测量，有3种方法：1、如果对测量误差不是特别建议（实际20mv以内），可以直接使用-12db测量0-3.3V；2、如果对精度有要求，建议先用-12db测量一下，然后根据实际电压选择对于的增益细测，这样牺牲一点时间，测量更准；3、还有就是最常规的方法，直接分压到可测量的范围，比如测量0~3.3V，如果使用分压电阻分到0-1.65V;开启PGA对输入信号进行缩放，实际会引入测量误差，建议使用的测量范围就是为了减少测量误差。</p><p>如果使用两个通道采样不同的电压，需要用到的增益不同的话，每次采样之前需要重新配置，因为ADC转换器只有一个。</p><p><strong>一个例子：</strong></p><p>比如我要测量一个7.4V电池的电压，一般电池满电的时候电压最高会达到7.8V左右，最低6V左右。</p><p>我选用电阻分压使得电池电压降低1/3，进行测量。</p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202202111555641.png" style="zoom:67%;" /><p>可以得到AIN的电压范围在2-2.6V。显然我们选择-6dB的GPA是最好的。测得ADC的值后，进行计算：(ADC/1024-1) * 1.05 * 3，即可得到真实的电源电压值。实测误差较小。但是当VCC_BAT在5V左右时，计算得到的电压值误差较大。</p><p>事实证明，如果对测量精度的要求较高，还是选择对应的GPA和对应的公式进行计算。</p><h2 id="粗校准"><a href="#粗校准" class="headerlink" title="粗校准"></a>粗校准</h2><p>使用ADC之前可以进行粗校准。粗调实际上就是<strong>对GND进行校准</strong>,ADC对GND读个值,计算出固定的偏移, 然后手动去offset其他通道的值;</p><p>这个偏移通常在几个LSB到几十个LSB 之间,可能是偏大, 或者偏小, 把校准值带入实际的采样值,来修正这个固定偏差。</p><p>对于CH573，可以使用6/7/10/11四个通道进行校准，当使用粗调时,内部模拟开关会控制该通道的电平,这几个通道均为内部通道。如果使用了外部通道，那么需要确保外部电路不会对校准产生影响。</p><p>如果对精度的要求较高，有一个AIN通道外加了基准源，那么可以不用进行粗校准而使用基准源进行校准。</p><p>CH573型号改进了ADC的结构，取消了<strong>细校准</strong>。需要细校准的CH577/578/579型号的细调,实际上是调节斜率。</p><h2 id="输入缓冲器"><a href="#输入缓冲器" class="headerlink" title="输入缓冲器"></a>输入缓冲器</h2><p>默认建议开启输入缓冲器，只有当外部信号源内阻小于 1KΩ时，才可以关闭输入缓冲器进行 ADC。 当采用差分输入时，建议关闭输入缓冲器。当用于 TouchKey 检测时，必须开启输入缓冲器，且 建议选择 0dB（优先）或-6dB 两种增益之一。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>CH573</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cubeMX入门使用教程</title>
    <link href="/2021/08/15/2021-8-15CubeMX%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/"/>
    <url>/2021/08/15/2021-8-15CubeMX%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p>本文以STM32F429IGT6为例讲解如何使用cubeMX配置STM32， 基于HAL库进行编程。</p><p>[TOC]</p><h2 id="初始化工程"><a href="#初始化工程" class="headerlink" title="初始化工程"></a>初始化工程</h2><h3 id="建立工程"><a href="#建立工程" class="headerlink" title="建立工程"></a>建立工程</h3><p>ACCESS TO MCU</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152154658.png" alt="image-20210814165034535"></p><p>输入型号，选择对应MCU</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152154047.png" alt="image-20210814165132318"></p><h3 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h3><p>在RCC选项中激活外部时钟，HSE选择外部晶振作为时钟源</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152154427.png" alt="image-20210814165414554"></p><p>配置时钟树，将HCLK频率设置为最高（看使用需求）</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152154743.png" alt="image-20210814165620210"></p><p>在sys选项中激活DEBUG，选择serial wire。</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152154790.png" alt="image-20210814165714498"></p><h3 id="配置工程"><a href="#配置工程" class="headerlink" title="配置工程"></a>配置工程</h3><p>在Project Manager中配置工程的名字，选择IDE为MDK-ARM</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152154641.png" alt="image-20210814165909024"></p><p>在Code Generator中勾选选项</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152155225.png" alt="image-20210814170028428"></p><p>点击GENERATE CODE即可生成工程文件</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152155775.png" alt="image-20210814170121101"></p><h2 id="如何编写代码"><a href="#如何编写代码" class="headerlink" title="如何编写代码"></a>如何编写代码</h2><h3 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h3><p>如你所见，官网生成的工程文件中注释全部使用/**/进行注释，全篇没有出现一处//注释。所以为了一致性，尽量不要使用//注释（强迫症）。</p><h3 id="用户代码"><a href="#用户代码" class="headerlink" title="用户代码"></a>用户代码</h3><p>用户编写的代码都要放入   USER CODE BEGIN   和   USER CODE END   之间，否则下一侧生成代码后用户代码就会被覆盖。</p><h2 id="配置USART"><a href="#配置USART" class="headerlink" title="配置USART"></a>配置USART</h2><p>箭头位置配置为Asynchronous即可</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152155937.png" alt="image-20210814170217959"></p><p>使用：</p><p>包含头文件：  #include &lt;stdio.h&gt;</p><p>printf重定向：   在main.c的user code 0中加入代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* printf重定向 */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fputc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ch, FILE *f)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">uint8_t</span> temp[<span class="hljs-number">1</span>] = &#123;ch&#125;;<br>    HAL_UART_Transmit(&amp;huart1, temp, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">/* huart1需要根据你的配置修改 */</span><br>    <span class="hljs-keyword">return</span> ch;<br>&#125;<br></code></pre></td></tr></table></figure><p>即可在程序中使用printf</p><h2 id="配置GPIO"><a href="#配置GPIO" class="headerlink" title="配置GPIO"></a>配置GPIO</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>点击引脚，在选择GPIO_INPUT即可</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152155795.png" alt="image-20210814172012257"></p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>点击引脚，在选择GPIO_OUTPUT即可</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152155924.png" alt="image-20210814171320220"></p><p>其他的模式选项怎么用会在后面介绍</p><h3 id="详细配置"><a href="#详细配置" class="headerlink" title="详细配置"></a>详细配置</h3><p>侧栏中选择GPIO点击想要配置的引脚</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152155063.png" alt="image-20210814172139106"></p><p>Configuration中，从上到下依次是：</p><p>GPIO初始化电平</p><p>GPIO输入（输出）模式</p><p>GPIO上下拉</p><p>GPIO速率</p><p>GPIO标签 （很重要）<strong>给GPIO设置标签以后（就和之前编程给引脚设置宏定义一个道理），移植程序就会方便很多，兼容性大大提高</strong></p><p>使用HAL_GPIO_WritePin();     控制IO电平</p><p>使用HAL_GPIO_ReadPin();      读取IO状态</p><h2 id="配置PWM输出"><a href="#配置PWM输出" class="headerlink" title="配置PWM输出"></a>配置PWM输出</h2><p>选择TIM，然后选择通道。选择PWM Generator 即可</p><p>选项解释：</p><p>PWM Generation CHx 正向PWM</p><p>PWM Generation CHxN 反向PWM</p><p>PWM Generation CHx 和 CHxN  组成一对互补PWM输出</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152155968.png" alt="image-20210815095241640"></p><p>设置PSC和Period来设置PWM的频率。</p><p>频率 = 定时器时钟（TIM挂载在的总线上的时钟） / （Prescaler 预分频 + 1）/ （Counter Period 计数值 + 1） Hz</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152155257.png" alt="image-20210815095345037"></p><p> 占空比 = Pulse ( 对比值) / （C ounter Period 计数值）%</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152155430.png" alt="image-20210815095748381"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 使能timx的通道y */</span><br>HAL_TIM_PWM_Start(&amp;htimx,TIM_CHANNEL_y); <br><span class="hljs-comment">/* 修改timx的通道y的pwm比较值为z，即修改占空比 */</span><br>__HAL_TIM_SET_COMPARE(&amp;htimx, TIM_CHANNEL_y, z);<br></code></pre></td></tr></table></figure><h2 id="编码器模式"><a href="#编码器模式" class="headerlink" title="编码器模式"></a>编码器模式</h2><p>适用于ABZ相的正交编码器</p><p>在Combined Channels中选择Encoder Mode。</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152156270.png" alt="image-20210815100153999"></p><p>Encoder Mode选择Encoder Mode TL1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief读取对应编码器的值</span><br><span class="hljs-comment"> * @paramuint8_t TIMx编码器的所用的TIM</span><br><span class="hljs-comment"> * @returnEncoder_TIM编码器的值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Read_Encoder</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> TIMx)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> Encoder_TIM;<br><span class="hljs-keyword">switch</span>(TIMx) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: Encoder_TIM= (<span class="hljs-keyword">short</span>)TIM1 -&gt; CNT;  TIM1 -&gt; CNT=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: Encoder_TIM= (<span class="hljs-keyword">short</span>)TIM2 -&gt; CNT;  TIM2 -&gt; CNT=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: Encoder_TIM= (<span class="hljs-keyword">short</span>)TIM3 -&gt; CNT;  TIM3 -&gt; CNT=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: Encoder_TIM= (<span class="hljs-keyword">short</span>)TIM4 -&gt; CNT;  TIM4 -&gt; CNT=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: Encoder_TIM= (<span class="hljs-keyword">short</span>)TIM5 -&gt; CNT;  TIM5 -&gt; CNT=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: Encoder_TIM= (<span class="hljs-keyword">short</span>)TIM6 -&gt; CNT;  TIM6-&gt; CNT=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: Encoder_TIM= (<span class="hljs-keyword">short</span>)TIM7 -&gt; CNT;  TIM7 -&gt; CNT=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: Encoder_TIM= (<span class="hljs-keyword">short</span>)TIM8 -&gt; CNT;  TIM8 -&gt; CNT=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 1  <span class="hljs-comment">/* 如果没有更多的TIM就改为  #if 0 */</span></span><br><span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: Encoder_TIM= (<span class="hljs-keyword">short</span>)TIM9 -&gt; CNT;  TIM9 -&gt; CNT=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">10</span>: Encoder_TIM= (<span class="hljs-keyword">short</span>)TIM10 -&gt; CNT;  TIM10 -&gt; CNT=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">11</span>: Encoder_TIM= (<span class="hljs-keyword">short</span>)TIM11 -&gt; CNT;  TIM11 -&gt; CNT=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">12</span>: Encoder_TIM= (<span class="hljs-keyword">short</span>)TIM12 -&gt; CNT;  TIM12 -&gt; CNT=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">13</span>: Encoder_TIM= (<span class="hljs-keyword">short</span>)TIM13 -&gt; CNT;  TIM13 -&gt; CNT=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">14</span>: Encoder_TIM= (<span class="hljs-keyword">short</span>)TIM14 -&gt; CNT;  TIM14 -&gt; CNT=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br><span class="hljs-keyword">return</span> Encoder_TIM;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过设置Input Filter来设置编码器的软件滤波。</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152156194.png" alt="image-20210815212108817"></p><p>（和其他模式的比较    待补充）</p><h2 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h2><p>如图，将TIM的internal Clock打上勾，然后设置psc和period。</p><p>定时频率 = 定时器时钟 / （预分频 +1）/（计数值 + 1 ）Hz。</p><p>定时时间 = 1 / 定时频率。</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152156927.png" alt="image-20210815212215907"></p><p>再将Global interrupt打上勾，就可以使用定时器中断了。</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152156571.png" alt="image-20210815212323488"></p><p>如果是高级定时器，勾选 TIM X update interrupt 后的 Enabled 框即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">HAL_TIM_Base_Start_IT(&amp;htim1);  <span class="hljs-comment">/* 使能定时器 */</span><br><br><span class="hljs-comment">/* 定时器中断回调函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HAL_TIM_PeriodElapsedCallback</span><span class="hljs-params">(TIM_HandleTypeDef *htim)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (htim-&gt;Instance == htim1.Instance) &#123;<br>    <br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(htim-&gt; Instance == htim2.Instance) &#123;<br>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中断回调函数机制"><a href="#中断回调函数机制" class="headerlink" title="中断回调函数机制"></a>中断回调函数机制</h3><p>在HAL库中，中断服务函数不再像标准库那样编写。</p><p>在cubeMX自动生成的代码中，每个使能的中断的回调函数都有一个__weak</p><p>修饰，代表着若函数，用户可以在用户文件中重新定义一个同名函数，最终编译器编译的时候，会选择用户定义的函数，如果用户没有重新定义这个函数，那么编译器就会执行__weak声明的函数，并且编译器不会报错。</p><p>用户将中断服务函数写在回调函数中即可。</p><h2 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h2><p>点击引脚，选择GPIO_EXTI</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152156940.png" alt="image-20210815213517511"></p><p>GPIO mode 设置边沿触发模式</p><p>GPIO Pull-up/Pull-down 设置上下拉</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152156580.png" alt="image-20210815213558683"></p><p>最后使能中断</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152156622.png" alt="image-20210815213718000"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 外部触发回调函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HAL_GPIO_EXTI_Callback</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> GPIO_Pin)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(GPIO_Pin == PWM_Pin) &#123;<br>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="配置GPIO（附加说明）"><a href="#配置GPIO（附加说明）" class="headerlink" title="配置GPIO（附加说明）"></a>配置GPIO（附加说明）</h2><p>根据数据手册可知，有些功能并不是只有一个引脚，比如说TIM8的CH1就有PC6和PI5可以用。</p><p>在Pinout View中设置了GPIO的mode后，在设置对应的外设，外设的引脚就会被映射到你所选择的引脚。</p><p>比如点击PI5选择TIM8_CH1，然后在在TIM8中设置CH1为PWM输出，那么PI5就会作为PWM输出脚。</p><p>PC6同理。</p><p><img src="https://gitee.com/BriMon-zZY/blog-image/raw/master/img/202108152156151.png" alt="image-20210815214556670"></p><p>以上是我个人使用cubeMX的一些经验，我会不断的补充。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
      <tag>HAL库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录电赛准备过程中那些踩过的坑和学到的知识</title>
    <link href="/2021/08/09/2021-8-9-2021%E7%94%B5%E8%B5%9B%E5%9B%BD%E8%B5%9B%E5%87%86%E5%A4%87%E5%8E%86%E7%A8%8B/"/>
    <url>/2021/08/09/2021-8-9-2021%E7%94%B5%E8%B5%9B%E5%9B%BD%E8%B5%9B%E5%87%86%E5%A4%87%E5%8E%86%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>作者：BriMonzZY</p><p>邮箱：<a href="mailto:&#49;&#54;&#49;&#x30;&#x39;&#x33;&#x37;&#x38;&#x38;&#x35;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;">&#49;&#54;&#49;&#x30;&#x39;&#x33;&#x37;&#x38;&#x38;&#x35;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;</a></p><p>gitee：<a href="https://gitee.com/brimon-zzy">https://gitee.com/brimon-zzy</a></p><p>github：<a href="https://github.com/BriMonzZY">https://github.com/BriMonzZY</a></p><h2 id="电磁曲射炮的制作"><a href="#电磁曲射炮的制作" class="headerlink" title="电磁曲射炮的制作"></a>电磁曲射炮的制作</h2><p>完整代码：<a href="https://github.com/BriMonzZY/RAILGUN">https://github.com/BriMonzZY/RAILGUN</a></p><h3 id="一些踩过的坑"><a href="#一些踩过的坑" class="headerlink" title="一些踩过的坑"></a>一些踩过的坑</h3><ul><li><p>控制舵机时，等待输出的PWM稳定后，再接通舵机电源可以避免舵机疯转。</p></li><li><p>在中断中不要使用HAL_Delay()进行延时，因为HAL_Delay()本身就是使用systick中断实现的，所以如果systick中断优先级比所在中断的优先级低，systick就无法被调用，程序就会一直卡死在里面，一直卡在HAL_Delay()的while里。HAL_Delay()本身是一个被__weak修饰的虚函数，可以被用户在其他位置重新定义。</p></li><li><p>程序卡死在判断标志位的while中：(例如要判断标志位flag)在你进入循环的时候，实际上是将flag从内存加载到寄存器里面运行的，在整个循环中，flag这个变量都只是在读取寄存器里面的值。当进入中断的时候，中断里面会从内存加载flag到寄存器，修改完之后又存到内存里，然后退出中断，再回到循环里面。但这个时候循环里使用的flag并没有重新从内存加载flag这个变量，所以一直都在循环里面。<br>而你在watch里面看到的send_flag变量，是通过调试接口读取对应的内存空间的，所以watch里面看到的值已经被修改了。<strong>所以这种变量要加volatile进行修饰</strong></p><p><strong>需要使用volatile的几种情况：</strong></p><p>1、中断服务程序中修改的供其它程序检测的变量需要加volatile；</p><p>2、多任务环境下各任务间共享的标志应该加volatile；</p><p>3、存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义；</p><p>另外，以上这几种情况经常还要同时考虑数据的完整性（相互关联的几个标志读了一半被打断了重写），在1中可以通过关中断来实现，2 中可以禁止任务调度，3中则只能依靠硬件的良好设计了。</p></li><li><p>IIC通信的线不能接的太长，否则会无法正常的进行通讯。中断可能会影响mpu6050的dmp的读取。</p></li><li><p>在调试摄像头寻找红色的代码的时候，程序进入HardFault_Handler()中断。stm32产生硬件错误。怀疑是内存溢出、访问越界(屏幕像素越界访问、数组越界访问都会造成这种情况)。</p><p><strong>在ARM架构的处理器的寄存器中：</strong>R14寄存器又称为链接寄存器(LR)，主要用来保存上一级函数调用者的返回地址。R13寄存器又称为堆栈指针寄存器(SP)，用来维护和管理函数调用过程中的栈帧变化。</p><p><strong>找出错误代码段：</strong></p><p>在Debug模式下：</p><p>如果R14(LR) = 0xFFFFFFE9，则查找主堆栈指针MSP。</p><p>如果R14(LR) = 0xFFFFFFFD，则查找进程栈指针PSP。</p><p>MSP=0x2002B1C8</p><p>在Memory Windows中查找0x2002B1C8。</p><p>找到0x08开头的32位地址输入disassembly可以看到出问题的代码。</p><p>解决方式：将easytracer的函数放到帧中断中问题就解决了。</p></li><li><p>姿态传感器解算角度的时候，一定要注意计算数据的间隔时间来更改相应参数。</p></li></ul><h3 id="关于PID的新的理解"><a href="#关于PID的新的理解" class="headerlink" title="关于PID的新的理解"></a>关于PID的新的理解</h3><p>舵机、步进电机这种执行器属于积分部件，所以使用增量式PID进行控制即可，不需要进行i控制，而直流电机属于不带积分的部件，所以使用位置式PID进行控制。</p><h2 id="麦克纳姆轮小车的制作"><a href="#麦克纳姆轮小车的制作" class="headerlink" title="麦克纳姆轮小车的制作"></a>麦克纳姆轮小车的制作</h2><p>麦轮车的四个轮子的速度需要进行闭环控制。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>电赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
